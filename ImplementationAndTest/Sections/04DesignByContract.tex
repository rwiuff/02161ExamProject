% !TeX root = ..\rapport_13_2.tex
\section{Design by contract}\label{chap:design_by_contract}

\subsection{generateProjectNumber} \label{sec:contract_generate_project_number}
pre: 
\begin{align}
    date \neq null
\end{align}
post:
\begin{align}
    \text{result } = \{s|\exists p \in projectRepository.getProjectNumbers : s \in p \land p = previousLargestProjectNumber + 1\}
\end{align}
\begin{align}
    3 + 4 = 7
\end{align}
\newline
\noindent
Med asserts ser det ud som følger:

\begin{listing}[H]
    \centering
    \caption{generateProjectNumber() med assertions}\label{lst:cgenerate_project_number_assertions}
    \begin{minted}[breaklines]{java}
public static String generateProjectNumber(Calendar date) {
  assert date != null // pre
  int year = DateHelper.twoDigitYearFromDate(date);
  int num = 0;

  // Find the highest incremental number for the current year
  for (String projectNumber : ProjectRepository.getInstance().all().keySet()) {
    if (projectNumber.startsWith(String.format("%02d", year))) {
      num = Integer.parseInt(projectNumber.substring(2));
    }
  }

  int previousProjectNumber = (year * 100) + num;
  int nextProjectNumber = (year * 1000) + num + 1;
  assert nextProjectNumber == previousProjectNumber + 1; // post
  
  if (nextProjectNumber < 10000) {
      return "0" + nextProjectNumber;
  }

  return "" + nextProjectNumber;

}
    \end{minted}
\end{listing}
\noindent
I virkeligheden er der to postconditions, i tilfælde af at preconditionen holder, sættes Employee-instancens initials-felt til init, i tilfælde af at den overtrædes, kastes en ExhaustedOptionsException.\\[4mm]
\subsection{createInitials()} \label{sec:contract_create_initials}
pre:
\begin{equation}
    nEmployeesWithName(employee) < maxInitials(employee)
\end{equation}
post:
\begin{equation}
    \{s | \exists e \in employeeRepository : s \in e.getInitials()\}
\end{equation}
Hvor maxInitials(employee) er $n$ vælg 2, hvor $n$ er længden af efternavnet, og duplikater fjernes i generationen af kombinationer.
I "Laudrup" (længde 7, $7 \choose 2$=21) går "lu", "au", "up" igen to gange, hvorfor der fås 18 og ikke de forventede 21. Der forklarer hvorfor white-box testens input er konstrueret som det er.\\[4mm]
Med asserts ser det ud som følger

\begin{listing}[H]
    \centering
    \caption{createInitials() med assertions}\label{lst:create_initials_assertions}
    \begin{minted}[breaklines]{java}
private void createInitials() throws ExhaustedOptionsException {
    EmployeeRepository employeeRepo = EmployeeRepository.getInstance();
    assert true; // pre

    for (int l1 = 0; l1 < lastName.length(); l1++) {
      for (int l2 = l1 + 1; l2 < lastName.length(); l2++) {
        String init = firstName.substring(0, 2)
            + lastName.substring(l1, Math.min(l1 + 1, lastName.length()))
            + lastName.substring(l2, Math.min(l2 + 1, lastName.length()));

        init = init.toLowerCase();
        if (!employeeRepo.initialsExist(init)) {
          this.initials = init;
          assert this.initials == init; // post
          return;
        }
      }
    }

    throw new ExhaustedOptionsException("Kunne ikke generere unikke initialer");
  }
    \end{minted}
\end{listing}
\noindent
Implicit garanteres det der står i createInitials' precondition gennem funktionens kørsel, derfor assertes blot true som precondition. I virkeligheden er der to postconditions, i tilfælde af at preconditionen holder, sættes Employee-instancens initials-felt til init, i tilfælde af at den overtrædes, kastes en ExhaustedOptionsException.\\[4mm]
pre: 
\begin{equation}
    title \neq null \wedge startWeek \neq null \wedge endWeek \neq null \wedge loggedInUser \neq null \wedge activities \neq null
\end{equation}

post: 
\begin{equation}
\begin{gathered}
    activity \in activities \wedge \\
    \neg project@pre.hasProjectActivity(title) \wedge \\
    (hasProjectLeader() \to projectLeader.isSameAs(loggedInUser))
\end{gathered}
\end{equation}

\begin{listing}[H]
    \centering
    \caption{createProjectActivity() kildekode med assertions}\label{lst:create_project_activity_assertions}
    \begin{minted}[breaklines]{java}
  public ProjectActivity createProjectActivity(String title, String startWeek, String endWeek, Employee loggedInUser)
      throws AlreadyExistsException, OperationNotAllowedException, InvalidPropertyException {

    assert title != null;
    assert startWeek != null;
    assert endWeek != null;
    assert loggedInUser != null;
    assert activities != null;

    if (hasProjectLeader()) {
      if (!projectLeader.isSameAs(loggedInUser)) {
        throw new OperationNotAllowedException("Kun projektlederen kan oprette en projekt aktivitet for dette projekt");
      }
    }

    if (hasProjectActivity(title)) {
      throw new AlreadyExistsException("Projekt aktivitet findes allerede");
    }

    ProjectActivity activity = new ProjectActivity(title, startWeek, endWeek);
    this.activities.add(activity);

    /**
     * NOTE: This post condition does not check for 
     * !project@pre.hasProjectActivity(title)
     */
    assert (
      activities.contains(activity) &&
      (!hasProjectLeader() || projectLeader.isSameAs(loggedInUser) )
    );

    return activity;
  }
    \end{minted}
\end{listing}


\subsection{findWorktimeRegistrationById()} \label{sec:contract_findd_work}
\noindent Precondition: I dette tilfælde er vores precondition \texttt{true}, da vores postconditions korrigerer for fejl, så alle tilfælde af inputs fejlhåndteres.

%\begin{align}
    %allWorktimeRegistrations().size()\; >\; 0 \;\wedge\; id \; \in %\; \mathbb{N} \; \wedge \; 0 \; < \; id  \; <=\; %allWorktimeRegistrations().size()
%\end{align}


\noindent
Postcondition: 
\begin{equation}
    \exists i\; :\; (result = i \iff\; \exists worktimeRegistration.getId() \; = \; i\; \lor result = NotFoundException)
\end{equation}\label{postcondition 1}

Det skal nævnes, at postconditionen, i tilfælde af at leddet før $\lor$ i ligningen over 


\begin{listing}[H]
    \centering
    \caption{findWorktimeRegistrationById() kildekode med assertions}\label{lst:find_work_time_registration_by_id_assertions}
    \begin{minted}[breaklines]{java}
public WorktimeRegistration findWorktimeRegistrationById(int id) throws NotFoundException {

    assert true // Precondition
    
    List<WorktimeRegistration> list = allWorktimeRegistrations();

    for (WorktimeRegistration worktimeRegistration : list) {
        if (worktimeRegistration.getId().equals(id)) {
            assert list.stream().anyMatch(x -> x.getId() == id) // Postcondition
            
            return worktimeRegistration;
        }
    }

    throw new NotFoundException("Ukendt tidsregistrering");

}
    \end{minted}
\end{listing}


